%%
%% ############# Evaluation
%%
\chapter{Evaluation der Frameworks}
\section{Auflistung des Evaluationsschlüssels}

Um die einzelnen Frameworks zu Evaluieren habe ich einen Schlüssel aufgelistet, welcher messbare Aspekte abdeckt, die ich im Vorfeld der Arbeit bereits als wichtig erachtet habe um die aufgestellte Thesis in Zahlen darzustellen. Ergänzend kamen Punkte hinzu die bei der Installation und der Nutzung auffielen und sich als wichtig erwiesen. 

\\Ich habe den Schlüssel in 7 Hauptkategorien aufgeteilt. Die Abschnitte Installation und Konfiguration befassen sich in erster Linie mit der Verfügbarkeit, dem Zugang zu dem Framework, deren Installation und Dokumentation sowie der Voraussetzung andere Technologien um es zu nutzen.

\subsubsection{Installation}
\begin{table}[H]
 	\vspace{-30pt}
 	\centering
	\rowcolors{1}{white}{lightgray}
		\begin{tabular}{| p{12cm} | c|}
			\hline
				Kriterium		 &	Punktezahl\\
			\hline
			\hline
				Notwendigkeit von anderen Technologien				&4\\
				Nutzbar direkt nach der Installation			&	2	\\
				Installationsanleitung vorhanden			&	2	\\
				FAQ vorhanden				&	2	\\
				\hline
		\end{tabular}
	\caption{Kriterienübersicht: Installation}
\end{table}

\subsubsection{Konfiguration}
\begin{table}[H]
 	\vspace{-30pt}
 	\centering
	\rowcolors{1}{white}{lightgray}
		\begin{tabular}{| p{12cm} | c|}
			\hline
				Kriterium		 &	Punktezahl\\
			\hline
			\hline
				Nutzbar ohne Konfiguration			&4\\
				Konfigurierbarkeit(IP und Ports)			&	1	\\
				Konfigurierbare Workspaces			&	2	\\
				Support vorhanden (Wiki, Helpdesk, EMail, Forum)				&	2	\\
				Intuitive Benutzeroberfläche			&	1	\\
				\hline
		\end{tabular}
	\caption{Kriterienübersicht: Konfiguration}
\end{table}

\\Der Teilschlüssel Funktion wurde dupliziert und in einen Mobilteil und einen Desktopteil aufgeteilt. Das hat den Grund, dass das testen von mobilen Seiten andere Schwerpunkte der Bewertung haben sollte, als das testen von Desktopseiten. So ist eine funktionierende synchrone Gestenkontrolle beim testen von mobilen Seiten zum Beispiel unerlässlich, wohingegen sie auf Desktops durch den Einsatz einer Maus tendenziell eher unhandlich in der Nutzung ist.
\subsubsection{Funktion: Desktop}
\begin{table}[H]
 	\vspace{-30pt}
 	\centering
	\rowcolors{1}{white}{lightgray}
		\begin{tabular}{| p{12cm} | c|}
			\hline
				Kriterium		 &	Punktezahl\\
			\hline
			\hline
				Darstellung : normale Seiten			&2\\
				Darstellung : gesicherte Seiten		&	2	\\
				 Darstellung: normale Reaktionsgeschwindigkeit ( < 1 Sekunde)	&	2	\\
				Funktion: Seitensteuerung			&	3	\\
				Funktion: Javascript			&	1	\\
				\hline
		\end{tabular}
	\caption{Kriterienübersicht: Desktop}
\end{table}

\subsubsection{Funktion: Mobil}
\begin{table}[H]
 	\vspace{-30pt}
 	\centering
	\rowcolors{1}{white}{lightgray}
		\begin{tabular}{| p{12cm} | c|}
			\hline
				Kriterium		 &	Punktezahl\\
			\hline
			\hline
				Darstellung : normale Seiten			&1\\
				Darstellung : gesicherte Seiten		&	1	\\
				 Darstellung: normale Reaktionsgeschwindigkeit ( < 1 Sekunde)	&	2	\\
				Funktion: Seitensteuerung			&	4	\\
				Funktion: Javascript			&	1	\\
				Funktion: Gestenkontrolle			&	1	\\
				\hline
		\end{tabular}
	\caption{Kriterienübersicht: Mobil}
\end{table}

\\Da es in der Praxis kein Framework gab, welches zum Zeitpunkt dieser Arbeit in der Lage war alle gewünschten Aspekte abzudecken, war es wichtig das Werkzeug um eigene Funktionen oder externe Frameworks zu ergänzen. Dies wurde unter Berücksichtigung der API, dessen Lizenz und Dokumentation bewertet.
\subsubsection{Erweiterbarkeit}
\begin{table}[H]
 	\vspace{-30pt}
 	\centering
	\rowcolors{1}{white}{lightgray}
		\begin{tabular}{| p{12cm} | c|}
			\hline
				Kriterium		 &	Punktezahl\\
			\hline
			\hline
				API Zugang			&5\\
				API lizenzteschnich gesichert	&	2	\\
				API Dokumentation	&	3	\\
				\hline
		\end{tabular}
	\caption{Kriterienübersicht: Erweiterbarkeit}
\end{table}

\\Ein weiterer wichtiger Aspekt ist die Unterstützung möglichst vieler verschiedener Browser auf dem Desktop, auf dem Mobilgerät und in der virtuellen Umgebung.

\subsubsection{Browser Support (aktuelle Versionen)} 
\begin{table}[H]
 	\vspace{-30pt}
 	\centering
	\rowcolors{1}{white}{lightgray}
		\begin{tabular}{| p{12cm} | c|}
			\hline
				Kriterium		 &	Punktezahl\\
			\hline
			\hline
				mobile Plattformen (iOS, Android, Windows)			&3\\
				Virtuelle Browser	&	2	\\
				Chrome				&	1	\\
				Opera				&	1	\\
				Firefox				&	1	\\
				Safari				&	1	\\
				Internet Explorer		&	1	\\
				\hline
		\end{tabular}
	\caption{Kriterienübersicht: Browser}
\end{table}

\\Die Aktivität einer Software lässt darauf schließen, ob und gegebenenfalls wie diese sich in Zukunft Entwickeln kann. So sind von einem inaktiven Entwicklungsstand von über einem halben Jahr keine neuen Ergebnisse mehr zu erwarten und man muss davon ausgehen das die Software um keine neuen Features erweitert werden wird.
\subsubsection{Aktivität}
\begin{table}[H]
 	\vspace{-30pt}
 	\centering
	\rowcolors{1}{white}{lightgray}
		\begin{tabular}{| p{12cm} | c|}
			\hline
				Kriterium		 &	Punktezahl\\
			\hline
			\hline
				Noch in der Entwicklung (letzes Release, Commit Häufigkeit)			&5\\
				Aktives Forum	&	5	\\
				\hline
		\end{tabular}
	\caption{Kriterienübersicht: Aktivität}
\end{table}



%%
%% ############# Ghostlab
%%
	\pagebreak
	\section{\mi{Ghostlab} Version 1.2.3}
		\subsection {Einrichtung der Testumgebung}
		Ghostlab kommt von Hause aus mit einer 7-Tage-Testversion. Die Installation verlief einfach und ereignislos. Nachdem das 		Tool Installiert wurde erfolgte die Zuweisung einer Website zu dem Ghostlabserver. Es wurden in diesem Fall sowohl eine 		Seite auf einem lokalen Apache Server getestet, als auch die mitgelieferte Demoseite von Ghostlab. Nach dem Start des 			Ghostlabservers ist dieser über den localhost\footnote{IP-Adresse des lokalen Rechners} auf Port 8005 (Default) von allen 		zu testenden Geräten erreichbar.
		\ig{../pictures/ghostlab/startbildschirm}{Startbildschirm Ghostlab}{Startbildschirm von Ghostlab nach der Installation}
		
		\subsection{Testen von Desktopbrowsern}
		Durch aufrufen der IP-Adresse des Rechners auf dem der Ghostlabserver läuft verbindet sich der Browser als Client und 			wird fortan durch gesendete Signale beeinflusst. Hierzu zählen auch virtuelle Browser. Jeder Client wird nun gleichzeitig 			Sender und Empfänger für Signale, dass bedeutet das jede Aktion parallel-synchron auf allen anderen Clients gespiegelt 			wird. Hierzu zählen Javascriptevents, das ausfüllen eines Formulars oder das neuladen der gesamten Seite.
		\ig{../pictures/ghostlab/workspaces}{Übersicht Clients}{Darstellung von 4 verschiedenen Clients } 
		
		Über den Übersichtsbildschirm kann jeder verbundene Client einzeln inspiziert werden. Hier ist der Nutzer in der Lage sich 		durch das DOM zu navigieren oder temporäre CSS Anpassungen vorzunehmen. Die Handhabung ist intuitiv, was jedoch an 		dem verwendeten Framework \mi{Weinre} liegt.
		\ig{../pictures/ghostlab/weinre}{Exemplarisch Weinreansicht}{ausgewähltes DOM-Element in Weinre}
		
		\pagebreak
		\subsection{Testen von mobilen Browsern}
		
		Das einrichten zum testen auf mobilen Endgeräten verläuft synchron zu den Desktopbrowsern. Man ruft innerhalb des 			Browsers die IP-Adresse des Ghostlabrechners auf und ist schon nach wenigen Sekunden\footnote{abhängig von der 			Geschwindigkeit des Testgerätes} in der Clientliste aufgenommen.
		
		\\Bei dem Testen auf mobilen Browserns ist es bei Ghostlab\footnote{Version 1.2.3} Notwendig ausreichend Zeit zwischen 		den Eingaben zu lassen, da es sonst bei unterschiedlich schnellen Geräten zu einem Effekt kommt, bei dem die 				langsameren Geräte beim ausführen des Letzen Signals gleichzeitig wieder zum Sender für alle anderen Geräte wird.
		\ig{../pictures/ghostlab/uebersicht_mobil}{Übersicht mobile Clients Ghostlab}{Ghostlabübersicht der verbundenen Clients}
		
		\pagebreak
		
		\subsection{Fazit zu Ghostlab}
		Zum Stand dieser Arbeit wurde Version 1.2.3 von Ghostlab genutzt. Zu diesem Zeitpunkt verfügte die Software noch über 		keinen Master/Slave-Modus\footnote{ein Gerät dient als Steuergerät, alle anderen folgen ihm}, dadurch kam es bei meinen 		Testgeräten bereits nach wenigen Minuten zu dem Problem, dass die Geräte sich in einer 								Endlosschelife von Senden und Empfangen der Steuerbefehle befanden. Für kommende Versionen ist ein solcher Modus 		laut den Entwicklern aber geplant. Das Problem rührt daher, dass einige Geräte schneller auf die übermittelten Befehle 			reagieren als andere. Das führt dazu, dass die langsam ladenden Geräte in dem Augenblick wo sie das Signal umsetzen, 		für die schnelleren Geräte bereits wieder als Sender fungieren. Dieses Problem sehe ich bei einer bereits kleinen Anzahl 			von Geräten als kritisch an. 

		\\Das testen in mehreren Browsern auf einem Rechner lief hingegen sehr gut. Das ausführen von Javascript läuft 				einwandfrei. Das ausfüllen von Inputs, Checkboxen, Radioboxen und das absenden des Formulars funktionierte bis auf die 		Kalenderauswahl im Firefox Browsers anstandslos. Ein Problem scheint das Werkzeug mit Passwortgeschützten Seiten zu 		haben. Diese lassen sich erst nach mehrfacher, abhängig vom jeweiligen Browser, Eingabe des Passwortes aufrufen. 			Diese Prozedur wiederholt sich für jede weitere Unterseite erneut. 

		\\Das arbeiten in einer Virtuellen Umgebung\footnote{es wurde VirtualBox von Oracle genutzt} wird problemlos unterstützt. 		Das einzige Problem was ich analysieren konnte war, dass sich virtuelle Browser nicht in einen Workspace integrieren 			lassen.

		\\Ghostlab unterstützt die Funktion von Workspaces\footnote{Arbeitsumgebung oder auch Arbeitsumfeld}, welche sich die 		Position und Größe der verschiedenen Browserfenster speichert. Per Knopfdruck lassen diese sich dann im Kollektiv öffnen 		sofern in den Browsereinstellungen die Popups aktiviert sind für die zu testende Seite. Dieses Feature\footnote{Funktion 			welche ein Teil der Anwendung ist} bewerte ich als Positiv in Hinsicht der Zeitersparnis, diesen Vorgang immer wieder von 		Hand auszuführen.

		\\Als Kritikpunkt bewerte ich die nicht existente Möglichkeit die Anwendung um eigene Funktionalität zu erweitern.

		\subsection{Tabellarische Evaluation}
		\met{Gewichtungstabelle Evaluation von Ghostlab}{10}{10}{8}{5}{0}{10}{5}
	
%%
%% ############# Adobe Edge Inspect
%%
	\pagebreak
	\section{\mi{Adobe Edge Inspect} CC }
		\subsection {Einrichtung der Testumgebung}
		Es sind 3 Schritte Notwendig Adobe Edge Inspect zum Einsatz bereit zu machen. Als erstes benötigen wir den Client aus 		der Adobe Creative Cloud (CC) Kollektion. Diese gibt es zum Zeitpunkt dieser Arbeit in verschiedenen Modellen und 			beginnt bei der kostenlose 30-Tage Testversion, geht über die Einzellizenz, für ausschliesslich Adobe Edge Inspect, von 			24,59€ / Monat bis hin zum Komplett-Abo was dann mit 61,49€ / Monat zu Buche schlägt. Dieser wird gestartet und läuft 		ab diesem Zeitpunkt als Deamon im Hintergrund. 
		\iga{../pictures/adobeedgeinspect/icon}{Adobe Edge Inspect Deamon Icon}{Der laufende Deamon von Adobe Edge Inspect}
		
		\\Als zweiten Schritt benötigen wir die zugehörige Chrome Extension von Adobe Edge Inspect. Diese wird über den Chrome 		Appstore installiert und kann nach einem Browserneustart aktiviert werden.
		
		\\Als letzes benötigen wir noch die kostenlos erhältliche App aus dem jeweiligen Shop. hier gilt für Android der Play Store, 		für iOS Geräte der AppStore. Windowsgeräte werden derzeit nicht unterstützt.
		
		\\Sind diese 3 Schritte erfolgreich durchgeführt worden, müssen nun die Geräte mit dem Server verbunden werden. Hierzu 		wird die App gestartet (der folgende Prozess verläuft unter Android wie auch unter iOS identisch) und per IP-Adresse mit 			der Adobe Edge Inspect Chrome Extension verbunden werden. Diese verlangt im Gegenzug einen Identifikationscode, 			welcher auf dem jeweiligen Gerät generiert wurde. Nach erfolgreicher Synchronisation wird das Gerät im Gerätemanager 		angezeigt.
		\igp{../pictures/adobeedgeinspect/iphone_2}{Adobe Edge Inspect App Client hinzufügen}{Eingabe der IP-Adresse zum 			Edge Inspect Rechner}{200}{350}
		\iga{../pictures/adobeedgeinspect/desktop_2}{Adobe Edge Inspect Chrome Extension}{Eingabe des Sicherheitscodes in die 		Chrome Extension}

		\\Dieser hat mehrere Funktionen. Er liefert eine Übersicht aller verbundenen Clients und ermöglicht das aufrufen von 			\mi{Weinre} um z.B. das DOM zu inspizieren, verwendete Ressourcen zu inspizieren oder Javascript auszuführen. Über 			den Gerätemanager lassen sich auch verbundene Geräte wieder durch einen Klick entfernen. Desweiteren kann man über 		dieses Interface Screenshot von allen verbundenen Geräten im aktuellen Zustand aufnehmen und anzeigen lassen. 			Weiterhin besteht die Möglichkeit den Darstellungsmodus auf den verbundenen Clients von der Appdarstellung in den 			Vollbildmodus zu wechseln.
		\iga{../pictures/adobeedgeinspect/desktop_3}{Adobe Edge Inspect Gerätemanager}{Übersicht der verbundenen Clients}
		
		\subsection{Testen von Desktopbrowsern}
		Es gibt zum Zeitpunkt der Erstellung dieser Arbeit keine Möglichkeiten Desktopseiten mit Adobe Edge Inspect zu testen.
		
		\subsection{Testen von mobilen Browsern}
		Die Funktionalität zum testen von mobilen Seiten beschränkt sich derzeit nur auf den synchronen Aufruf von Seiten über 			den Chromebrowser mit installierter Extension als Steuergerät. Die verbundenen Geräte erkennen den Aufruf von Links 			und das wechseln von Tabs innerhalb des Browsers. Es besteht wie bereits beschrieben die Option die einzelnen Clients 			per \mi{Weinre} zu untersuchen.
		
		\\Die simulierung eines Scrollevents oder das ausfüllen eines Formulars ist nicht möglich. Es werden lediglich die 				Informationen Dargestellt die am Steuergerät aufgerufen wurden. Jedoch wird der Client, sofern vorhanden auf die mobile 		Seite weitergeleitet. Während des Testens in der App wird das Display aktiv gehalten, wodurch es sich nicht von selbst 			abschaltet. Ein gutes Feature von Adobe Edge Inspect ist die Möglichkeit aus dem Gerätemanager des Browsers 				Screenshots der verbundenen Geräte anzufordern. Diese werden zusammen mit einer Beschreibung des Geräts, dessen 		Modellbezeichnung , die Auflösung sowie Pixeldichte, dem Betriebssystems, der aufgerufenen URL sowie der aktuellen 			Ausrichtung des Bildschirms ausgeliefert.
		\igp{../pictures/adobeedgeinspect/iphone_3}{Adobe Edge Inspect App Content Darstellung}{Darstellung von Content in der 		Adobe Edge Inspect App unter iOS}{200}{350}
		
		Während meiner Versuche ist mir aufgefallen, dass Adobe Edge Inspect unter iOS 6.1.3, Seiten die durch htaccess 				gesichert Sind nicht darstellen kann. Auf den anderen Testgeräten verlief der Prozess der Authentifizierung problemlos. 
		
		\pagebreak
		\subsection{Fazit zu Adobe Edge Inspect}
		Adobe Edge Inspect bedarf viel Aufwand für ein relativ geringes Ergebnis. Man muss an 3 verschiedenen Punkten 				Installationen vornehmen, die dann jedoch ohne Probleme miteinander harmoniert haben. Als besonders Positiv möchte ich 		die Screenshotfunktion bewerten. In Zusammenspiel mit der öffentlich zugänglichen API lassen sich hierüber Screenshots 		im Landschafts, als auch im Portraitmodus anfordern und durch eine externe Applikationen auswerten. 
		
		\\Der Nutzen des Werkzeugs liegt am ehesten bei One-Page-Sites\footnote{Webseiten dessen Inhalt sich füllend auf die 			gesamte Seite erstrecken} oder für Fehlersuche innerhalbs des DOM oder CSS Anpassungen mit \mi{Weinre}. Unter dem 		Aspekt 	des parrallel-synchronen Testens ist Adobe Edge Inspect leider nicht sinnvoll zu verwenden, da wed er 				Steuerbefehle oder 		andere Gesten umgesetzt werden, noch werden die Nutzereingaben in Eingabefeldern mit 			anderen verbundenen Clients geteilt. 	Alle verbunden Clients sind nur Empfänger und besitzen keine Möglichkeit 			als 			Sender zu fungieren. Folglich gehen alle 			Steuerbefehle vom Edge-Server aus.
	
	\subsection{Tabellarische Evaluation}
		\met{Gewichtungstabelle Evaluation von Adobe Edge Inspect}{10}{7}{0}{4}{8}{3}{10}


%%
%% ############# Remote Preview
%%
	\pagebreak			
	\section{\mi{Remote Preview}}
		\subsection {Einrichtung der Testumgebung}
		Es gibt zwei Möglichkeiten dieses Werkzeug zu nutzen. Die eine ist die Installation auf einem lokalen Apache-Server mit 			PHP. Die andere ist die Installation auf einem Cloud-Dienst wie z.B. Dropbox. Die Ergebnisse dieser Arbeit hab ich mit der 		lokalen Apache Installation erzielt. Die Installation sieht lediglich vor das Framework in einen lokalen Entwicklungszweig zu 		entpacken.
		
		\subsection{Testen von Desktopseiten}
		Alle Clients die in die Testumgebung eingebunden werden sollen müssen lediglich die IP-Adresse des Servers eingeben.
		Die Steuerung der Seiten erfolgt sowohl für Desktopseiten als auch für die mobilen Vertreter über die Browsermaske des 			Frameworks. In das untere der beiden Eingabefelder gibt man die aufzurufende URL inklusive Präfix\footnote{http://} ein. 			Diese wird dann auf allen verbundenen Clients innerhalb eines iFrames dargestellt. 
		\ig{../pictures/remotepreview/eingabemaske}{Remote Preview Steuerungsmaske}{Steuerungsmaske zur Eingabe der 			aufzurufenden URL}
				
		 \subsection{Testen von mobilen Browsern}
		 Das Testen der mobilen Browser funktioniert parallel zum testen von Desktopseiten. Positiv möchte ich hier erwähnen, 			dass das Framework auch wenn es dafür nicht ausgelegt ist, dennoch unter aktuellen Windowsgeräten funktioniert.			
		
		\subsection{Fazit zu Remote Preview}
		Ein positiver Punkt ist die Möglichkeit letztendlich jeden Browser unabhängig von dessen Betriebssystems in die 				Testumgebung zu integrieren, da diese einfach nur auf den ApacheServer oder die Dropbox zugreifen müssen. Als Negativ 		führe ich hier die Tatsache auf das es ähnlich Adobe Edge Inspect lediglich dem Aufruf von Seiten dient, jedoch nicht 			dessen Bedienung. So ist es nicht möglich weiteren Verlinkungen zu folgen ohne diese von Hand in der Eingabemaske 			einzutragen oder Formulare auszufüllen. Bedingt funktioniert das Darstellen von Seiten mit Ankern. Das Aufrufen von 			gesicherten Seiten gelang mir nicht. Ebenfalls war es  mir nicht möglich zertifizierte Webseiten aufzurufen, was den 				Nutzungsgrad des Frameworks stark einschränkt. Gut finde ich die Tatsache das Quellcode komplett zugänglich ist, da er 		unter der MIT Lizenz steht und	jederzeit in eigene Projekte eingebunden oder um eigene Funktionalität erweitert werden 			kann. Somit kann man Remote Preview nutzen und es um erweiterte Funktionalität erweitern kann. Das Projekt 				scheint zum Zeitpunkt dieser Arbeit nicht weiter entwickelt zu werden. Für den Aufruf einer einfachen Seite auf n-Geräten 		ist dieses Projekt eine kostenlose Alternative zu Adobe Edge Inspect mit geringerem Funktionsumfang.
		
				
		\subsection{Tabellarische Evaluation}
		\met{Gewichtungstabelle Evaluation von Remote Preview}{8}{6}{3}{3}{8}{10}{0}
		
	
%%
%% ############# Browser-Sync
%%
\pagebreak
	\section{\mi{Browser-Sync}}	
	\subsection{Einrichtung der Testumgebung}
	Um Remote-Sync nutzen zu können wird zu Beginn erst einmal eine NodeJS Implementation benötigt. Diese kann entweder über die Konsole installiert werden oder per Installationstool von der NodeJS Homepage.
	
	\\Nach der NodeJS Installation wird per NPM das Paket von Browser-Sync per Konsole einmalig installiert:
	\iga{../pictures/browser-sync/install}{Browser-Sync Installation per Konsole}{Konsolenbefehl um Browser-Sync zu installieren}
	
	Nun muss für jedes neue oder bestehende Projekt einmalig im Projektordner Browser-Sync initialisiert werden. Browser-Sync legt in dem aktuellen Verzeichnis eine Konfigurationsdatei ab, in welcher man einzelne Optionen wie die zu beobachtenden Dateien oder Einstellungen zum Synchronisationsverhalten. Dies geschieht ebenfalls über die Konsole:
	\igp{../pictures/browser-sync/init}{Browser-Sync Initiierung per Konsole}{Konsolenbefehl um Browser-Sync zu imitieren}{450}{200}
	
	Nach der Initiierung des Servers startet man diesen mit dem Befehl :
	\iga{../pictures/browser-sync/start}{Browser-Sync Starten per Konsole}{Konsolenbefehl um Browser-Sync zu starten}
	
	Um nun die Kommunikation zwischen dem Server und dem Projekt zu gewährleisten muss vor dem Ende des Body Elements der Indexdatei zusätzlicher Scriptcode eingefügt werden, welcher jedoch zum Release entfernt werden sollte. Der einzufügende Code  wird anhand der Konfigurationsdatei und der IP-Adresse des Servers generiert und per Konsole dem Nutzer mitgeteilt.
	\igp{../pictures/browser-sync/start2}{Browser-Sync Script-Tag}{Konsolenausgabe mit einzufügendem Quellcode}{450}{200}
	
	In künftigen Versionen wird es laut dem Entwickler nicht mehr Notwendig sein die Versionsnummer mit anzugeben.
	
	\subsection{Testen von Desktopseiten}
	Das Testen erfolgt durch Aufruf der Seite, in die der Steuercode eingetragen wurde, über den Browser. Die parallele Steuerung erfolgt direkt und synchron. Ist ein Browser erfolgreich verbunden, wird dies in der Konsole des Servers angezeigt.
	\iga{../pictures/browser-sync/connected}{Browser-Sync verbundener Client}{Konsolenausgabe bei erfolgreich verbundenem Client}
	Das folgen von internen Links funktioniert nur Unidirektional, sofern der Steuercode nicht mittels Framework oder von Hand in die verlinkten Dateien eingefügt wurde. Das folgen externer Links erfolgt nur Unidirektional. Auch das aufrufen zertifizierter oder gesicherter Seiten mit Passworteingabe funktioniert Problemlos. Beim nutzen von Steuerbefehlen traten nur bedingt Probleme auf. So gibt es zum Zeitpunk dieser Arbeit Defizite im Umgang mit dem Javascriptframework jQuery. So lassen sich z.B. Lightboxen öffnen, jedoch werden dann Befehle zum Schliessen des Fensters nicht mehr erkannt und übermittelt. Das ausfüllen von Formularen verlief bis auf eine Mehrfachauswahl fehlerfrei. Das erkennen von Hoverevents funktionierte in der Version 0.7.2 noch nicht. Auch das parallele Verwenden von Sliderelementen war zu diesem Zeitpunkt noch nicht implementiert.
	
	\subsection{Testen von mobilen Browsern}
	Das testen von mobilen Browsern verläuft parallel zu Desktopseiten. Ein Aufruf über den internen Browser genügt um den Client am Server zu registrieren. Als zusätzliches Problem trat bei den mobilen Geräten ein Verzug an Elementen auf. Die Geräte richten sich anhand der gescrollten Entfernung aus und bieten zum Zeitpunkt dieser Thesis nicht die Möglichkeit der Ausrichtung an Elementen der Internetseite. So kommt es bei den Testgeräten zu Unstimmigkeiten im dargestellten Inhalt, welche durch die Unterschiedlichen Auflösungen und Ausrichtungen der Geräte zu Stande kommen.
	
	\subsection{Fazit zu Browser-Sync}
	Browser-Sync ist ein viel Versprechendes Framework, welches die zu untersuchenden Aspekte vollkommen abdeckt. Es bestehen noch relativ viele unausgereifte Komponenten, jedoch werden diese bei auftreten, Zeitnah von den Entwicklern behoben. Generell scheint das Framework zum Zeitpunkt dieser Arbeit eine hohe Entwicklungsgeschwindigkeit zu besitzen. Es trat gelegentlich ein Fehler auf bei dem ein verbundener Client, selbst nach mehrfacher Neuverbindung, nicht mehr auf die Steuersignale reagierte. Dieser Fehler trat bei meistens bei mehr als 6 verbundenen Klienten auf. Das Framework ist zum validieren von Websites gedacht, die sich noch in der Entwicklung befinden. Das testen ist aufgrund der notwendingen Testumgebung nur zum lokalen Arbeiten vorgesehen. Als Pluspunkt wird das injizieren von geändertem Code zur Entwicklungszeit gewertet. So ist es Möglichen zum Beispiel vorgenommene Änderungen am Styling oder dem DOM ohne weitere Handgriffe direkt auf allen Testgeräten zu begutachten.
	
	\subsection{Tabellarische Evaluation}
		\met{Gewichtungstabelle Evaluation von Remote Preview}{5}{2}{9}{7}{8}{10}{10}
	
	
	\section{Eigenes \mi{Framework}}
	Der Ursprüngliche Gedanke dieser Arbeit verfolgte dn Ansatz ein eigenes Framework zu entwickeln, was die parallel-synchrone Steuerung auf mehreren Endgeräten insbesondere auf mobilen Geräten ermöglicht. Diesen Gedanken berücksichtigend erfolgte eine Validierung verschiedener Einzeltechnologien die nur gewisse Aspekte abdecken. Untersucht wurden diese in Hinsicht auf ihre tatsächliche Funktionalität, ihre Installation und Kombinierbarkeit mit anderen verwendeten Frameworks.
	
\\Die Bibliotheken werden insbesondere auf ihre Implementation in einen Node.JS Server überprüft.

	\subsection{Installation eines Node.JS Servers}
	Die Installation des Node.JS Servers erfolgt einfach über die Konsole unter Mac oder den Installer\footnote{erhältlich unter Nodejs.org}. Alleinstehend erfüllt dieser Server keinerlei der gewünschten Funktionen, jedoch dient dieser als Grundlage für einige nachfolgende Frameworks. Node.JS ist eine gute Wahl aufgrund der hohen Verarbeitungsgeschwindigkeit sowohl Client als auch Server seitig. Weitere Pluspunkte sind die rasche Entwicklungsgeschwindigkeit, die hohe Vielfalt an Erweiterungen und Plugins, sowie eine sehr große aktive Entwicklergemeinde.
	\subsection{Einbinden von socket.io}
	socket.io lässt sich einfach über den NPM installieren. Es ermöglicht das herstellen einer permanenten Verbindung mit dem Server über einen Socket. Der Vorteil liegt hierbei darin, dass keine zyklischen Anfragen an den Server gesendet werden. Stattdessen wird hier das Observer-Pattern umgesetzt und alle verbundenen Clients werden vom Server informiert sobald eine Änderung des Status stattgefunden hat. 
	
	\subsection{Generierung von Steuerbefehlen über socket.io}
	Der generelle Aufbau von socket.io sieht vor, dass der Client sicht mit dem Server verbindet und eine permanente Verbindung mit diesem aufrecht erhällt. Identifizierbar bleibt diese über eine generierte, einzigartige, alphanumerische Session ID. socket.io funktioniert nach den Observer-Pattern, dass bedeutet das der Client nicht in zyklischen Abständen Anfragen an den Server sendet, sondern bei einer Änderung der Modelle oder zum Beispiel einem Funktionsaufruf vom Server mittels eines Broadcasts informiert wird. So entsteht das Problem, dass wenn ein Client eine Nachricht an den Server sendet, dieser allen Clients (auch dem Auslöser) diese Nachricht sendet. 
	
	\igp{../pictures/broadcast}{socket.io vereinfachte Darstellung eines Broadcasts}{socket.io Broadcast \cite{3}}{300}{300}
	
Für die entwicklung eines eigenen Frameworks wirft dies einige Probleme auf.

\\ Ein  Beispiel: Ein Nutzer klickt auf einer Seite auf einen Button. Das senden-Event wird an den Server gesendet und an alle per socket verbundenen Clients dupliziert. Somit würde der ursprüngliche Sender des Signals, erneut das selbe Event erhalten. Das Resultat wäre, dass dieser Den Button zweimalig drückt. Das kann zu Problemen führen, weil beispielsweise eine Clientseitie Aktion mehrfach ausgeführt wird. Ein weiteres Problem kann durch rekursives Aufrufen einer Methode einen Dead-Lock erzeugen. Clients die empfangen Signale langsamer als andere verarbeiten, können in dem Moment vom Empfänger direkt wieder zum Sender werden.
	
	\\Daher ist der Ansatz ein Master-Slave-Pattern umzusetzen denkbar sinnvoll. Es wird ein Steuergerät definiert, welches seine Aktionen dem Server mitteilt und dieser die Events dann an alle verbundenen Clients innerhalb eines Aktionsraumes sendet.
	
	\igp{../pictures/broadcastroom}{socket.io vereinfachte Darstellung eines Broadcasts mit einem Aktionraum}{socket.io Broadcast mit Aktionsraum}{350}{350}
	
	\subsection{Implementierung eines einfachen Broadcast}
	Das Beispiel soll veranschaulichen wie ein einfacher Broadcast ohne Aktionsraum implementiert werden kann. Das Beispiel soll das Scrollevent des Clients abfangen und auf allen verbundenen Clients an die selbe Position auf dem Bildschirm scrollen.
	
	\subsubsection{Serverseitig}
	Zu Begin werden die notwendigen Bibliotheken eingebunden um einen NodeJS Server starten zu können (Zeilen: 1-2). Im Anschluss wird  eine Serverinstanz von NodeJS erstellt (Zeile: 4) und gestartet auf Port 8001 (Zeile: 6). Dieser wird nun mit der socket.io Bibliothek verknüpft (Zeile: 7). Sofern nun ein Client sich mit dem Server verbindet wird das \frqq connection\flqq-Event gefeuert (Zeile: 9) und der Client wartet auf ein selbstdefinierten Methodenaufruf vom  \frqq scroll\flqq (Zeile: 11).
	
	\\Wenn am Server ein Srollevent eingegangen ist sendet dieser dies per Broadcast an alle verbundenen Clienten (Zeile: 12).
	
	\igp{../pictures/socketio/server_1}{socket.io Quellcode Scrollbeispiel Serverseitig}{minifizierter Quellcode Serverseitig}{350}{350}
	\subsubsection{Clientseitig}
	Auf der Seite des Clients müssen zwei Methoden implementiert werden. Zum einen die Methode die das Scrollevent des Browsers, was hier über jQuery erfolgt, abfängt und über die Socketverbindung die Servermethode \frqq scroll\flqq  aufruft und die aktuelle Scrollposition zum oberen Bildschirmrand übergibt.
	
	\igp{../pictures/socketio/client_1}{socket.io Quellcode Scrollbeispiel Clientseitig}{minifizierter Quellcode Clientseitig}{350}{350}
	
	Zum anderen muss die Methode implementiert werden, welche vom Server gesendete Events abfängt und verarbeitet. In diesem Beispiel wartet der Client auf ein Event vom Typ \frqq scroll \flqq. Dieses bekommt einen Datensatz, die Scrollposition, mitgeliefert. Nach erfolgreichem Eventaufruf wird per jQuery die Position des Bildausschnittes an den des mitgelieferten Datensatzes angepasst.
	
	\igp{../pictures/socketio/client_2}{socket.io Quellcode Scrollbeispiel Clientseitig}{minifizierter Quellcode Clientseitig}{250}{250}

	\subsection{Einschätzung zur Umsetzung eines eigenen Frameworks}
	Der realisierung eines eigenen Frameworks zur parallel-synchronen Steuerung von Webseiten steht nichts im wege. Die sehr schnelle Datenübertragung in nahezu Echtzeit mittels Node.JS, Vorraussetzung ist hier, dass die Geräte sich im gleichen Lokalen Netz befinden, die einfache Implementierung von Steuersignalen über socket.io und die modulare Grundstruktur der Frameworks ermöglichen einen einfachen Einstieg in die Materie.

\\Die Struktur ermöglicht es sämtliche Events abzufangen, egal ob mit jQuery oder anderen Frameworks zur Eventermittlung, um diese dann in entsprechende Funktionen umzuwandeln und an alle Clients weiterzugeben. Der Einsatz eines Mastergerätes und das nutzen von Aktionsräumen verhindern die irreführende Rückkopplungen innerhalb des Nachrichtenzyklus. 

\\Der Einsatz in einer virtuellen Umgebung erfolgt Problemlos, da keine weitere Software installiert werden muss. DieVerwendung von Socket.io ermöglicht die Unterstützung aller alten Browser Plattformen da das Framework mit einer Reihe von Fallbacks sich gegen Funktionsverlust absichert. Sollte keine WebSocket-Technologie verfügbar sein greift das Framework zuerst auf Adobe Flash Sockets zurück und sollte dies auch nicht Verfügbar sein auf eine Reihe verschiedener Long-Polling-Ansätzen um die Kommunikation weiterhin zu gewährleisten.