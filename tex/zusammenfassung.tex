\chapter{Zusammenfassung und Ausblick}
Zum Abschluss der Arbeit, werde ich in einem Fazit auf gesetzte Ziele eingehen und die Vorgehensweise der Evaluierung schildern. Im Anschluss wird ein kleiner Ausblick gewährt, was basierend auf dem aktuellen Stand der \Gls{Framework} eventuell verbessert oder noch entwickelt werden könnte.

\section{Zusammenfassung}
Das Ziel dieser Arbeit war die Evaluierung von Techniken zur
parallel-synchronen Bedienung einer
Web-Applikation auf verschiedenen
mobilen \Gls{moEn}en. Zu Beginn wurden erst einmal \Gls{Framework}s ermittelt, welche die gesetzten Kriterien versprechen ganz oder zu großen Teilen abzudecken. 
Derzeit gibt es nur sehr wenige Anbieter von Produkten für parallele Webseitentests und das Angebot wird durch den Wunsch diese Tests auf mobile Geräte zu erweitern eingeschränkt. Auf Grund dessen wurden auch Segmentframeworks analysiert, welche in Kombination miteinander die Möglichkeit bieten, die geforderten Kriterien zu erfüllen. Im nächsten Schritt wurden diese kurz vorgestellt.

\\Als nachfolgender Schritt wurde ein Evaluationsschlüssel festgelegt, welcher zum einen Teil aus geforderten Kriterien abgeleitet wurde und zum anderen im Laufe dieser Arbeit um Kriterien erweitert, welche beim Einrichten und Verwenden der einzelnen Werkzeuge als für die Evaluierung wichtig empfunden wurden. Anhand des Schlüssels konnten die Komplettframeworks miteinander, in ihren Stärken und Schwächen, bewertet werden.

\\Im Anschluss wurden die \Gls{Framework}s installiert, konfiguriert und mit dem Desktopbrowser sowie mit einer Vielzahl von mobilen \Gls{moEn}en getestet, wobei auftretende Fehler oder Lob für eine gute problemlösende Funktion dokumentiert wurden. Am Ende jedes \Gls{Framework}testes erfolgte eine tabellarische Evaluierung in welcher Pro und Contra ersichtlich wurde. Außerdem wurde ein Wert anhand der einzelnen Unterkategorien errechnet, welcher in der Gesamtwertung einen Vergleich der \Gls{Framework}s untereinander ermöglichte.

\\
Das Ziel der Arbeit war es eine Übersicht, der sich am Markt befindlichen Werkzeuge, zu schaffen, welche dem Qualitätsmanagement ein, aus der Zeitersparnis resultierendes, effizienteres Arbeiten ermöglicht. Dieses Ziel erreichte leider keins der getesteten \Gls{Framework}s vollends, da sie nie alle Kriterien abdeckten und somit nach wie vor von Hand nachgetestet werden musste. 
Die einzelnen \Gls{Framework}s haben in der Regel jeweils einen Schwerpunkt gut abgedeckt, jedoch dafür andere Aspekte vernachlässigt. Positiv ist das open-source Projekt Browser-Sync aufgefallen. Es erfüllte am besten die gesetzten Kriterien und ist zusätzlich um eigene Funktionalitäten erweiterbar. Zusätzlich basiert Browser-Sync auf \gls{NodeJS} was es dem Entwickler ermöglicht auf die umfassende Paketdatenbank von \Gls{NPM} zuzugreifen und sie in das \Gls{Framework} zu implementieren. 

\\Auch das kommerzielle Ghostlab Produkt hat ein sehr solides Grundgerüst, jedoch gibt es gerade im Bereich des mobilen Testens eine Schwachstelle die das Arbeiten, zumindest mit älteren Generationen von Mobilgeräten, fast unmöglich macht. Da es leider keine Möglichkeit bietet das Programm um eigenen Code zu erweitern und dieser derzeit noch über keinen Master-Slave-Modus verfügt, verfängt es sich sehr schnell in einem zyklischen Deadloop.

\\Abschließend ist zu sagen, dass nach den gesetzten Kriterien, zum Zeitpunkt der Erstellung der Arbeit, keines der Komplettframeworks in der Lage ist den \Gls{qs}sprozess effizient zu optimieren.

\\Ich persönlich habe während dieser Arbeit gelernt wie wichtig eine gut strukturierte Planung ist. Diese um Zeitfenster für Eventualitäten zu erweitern und dennoch im Zeitrahmen zu bleiben, war eine große Herausforderung, da Teile dieser Arbeit experimentell waren und daher schwer in Zahlen zu fassen. Das Evaluieren der einzelnen \Gls{Framework}s lief hingegen überwiegend innerhalb des gesetzten Rahmens. Eine weitere Herausforderung war es die getesteten \Gls{Framework}s zu vergleichen und dies in Zahlen darzustellen, ohne dabei willkürlich zu wirken. Letzendlich hatte ich auch erhofft ein \Gls{Framework} zu finden, was alle meine Wünsche nach einem verbesserten Workflow erfüllt, jedoch stecken viele der Technologien noch in den Kinderschuhen und einige davon sind aber auf dem richtigen Weg und entwickeln mit Nachdruck daran dieses Ziel auch zu erreichen.


	 \vspace{-20pt}
	 \newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
	\begin{table}[H]
 		\centering
		\rowcolors{1}{white}{lightgray}
			\begin{tabular}{| p{9cm} | C{1cm} | C{1cm} | C{1cm} | C{1cm} |}
			\hline
							 	&	GL	&	AEI	&	RP	&	B-S\\
			\hline
			\hline
				Installation						&		&		&		&	\\
				Notwendigkeit von anderen Technologien	&	4	&	4	&	4	&	2\\
				Nutzbar direkt nach der Installation		&	2	&	2	&	2	&	2\\
				Installationsanleitung vorhanden		&	2	&	2	&	2	&	1\\
				FAQ vorhanden						&	2	&	2	&	0	&	0\\
				\hline
				\hline
				Konfiguration						&		&		&		&	\\
				Nutzbar ohne Konfiguration			&	4	&	4	&	4	&	0\\
				Konfigurierbarkeit (IP und Ports)		&	1	&	0	&	1	&	1\\
				Konfigurierbare \Gls{Workspace}s			&	2	&	0	&	0	&	0\\
				Support vorhanden (Wiki, EMail, Forum)	&	2	&	2	&	0	&	1\\
				Intuitive Benutzeroberfläche			&	1	&	1	&	1	&	0\\
				\hline
				\hline
				Funktion: Desktop					&		&		&		&	\\
				Darstellung : normale Seiten			&	2	&	0	&	1	&	2\\
				Darstellung : \gls{gesichert}e Seiten			&	2	&	0	&	0	&	2\\
				Darstellung: Reaktionsgeschwindigkeit	&	2	&	0	&	2	&	2\\
				Funktion: Seitensteuerung				&	3	&	0	&	0	&	3\\
				Funktion: \Gls{Javascript}					&	1	&	0	&	0	&	0\\
				\hline
				\hline
				Funktion: Mobil						&		&		&		&	\\
				Darstellung : normale Seiten			&	1	&	1	&	1	&	1\\
				Darstellung : \gls{gesichert}e Seiten			&	0	&	1	&	0	&	1\\
				Darstellung: Reaktionsgeschwindigkeit	&	2	&	2	&	2	&	2\\
				Funktion: Seitensteuerung				&	2	&	0	&	0	&	3\\
				Funktion: \Gls{Javascript}					&	0	&	0	&	0	&	0\\
				Funktion: Gestenkontrolle				&	0	&	0	&	0	&	0\\
				\hline
				\hline
				Erweiterbarkeit						&		&		&		&	\\
				API Zugang						&	0	&	5	&	5	&	5\\
				API lizenztechnisch gesichert			&	0	&	0	&	2	&	2\\
				API Dokumentation					&	0	&	3	&	1	&	1\\
				\hline
				\hline
				Browser Support (aktuelle Versionen)	&		&		&		&	\\
				mobile Plattformen					&	3	&	2	&	3	&	3\\
				virtuelle \Gls{Webbrowser}					&	2	&	0	&	2	&	2\\
				Chrome							&	1	&	1	&	1	&	1\\
				Opera							&	1	&	0	&	1	&	1\\
				Firefox							&	1	&	0	&	1	&	1\\
				Safari							&	1	&	0	&	1	&	1\\
				Internet Explorer					&	1	&	0	&	1	&	1\\
				\hline
				\hline
				Aktivität							&		&		&		&	\\
				Noch in der Entwicklung				&	5	&	5	&	0	&	5\\
				Aktives Forum						&	0	&	5	&	0	&	5\\
				\hline
				\end{tabular}
			\caption{{\"U}bersicht der \Gls{Framework}s: GL(Ghostlab), AEI(Adobe Edge Inspect), RP(Remote Preview), B-S(Browser-Sync)}
	\end{table}


\subsection{Ausblick}

Derzeit besitzt Browser-Sync wohl das höchste Potential, ein Produkt zu liefern, welches die Produktivität in der Web-Applikationsentwicklung steigert. Die lebendige Open-Source-Community ist aktiv und engagiert ein hochwertiges \Gls{Framework} zu erschaffen, welches leichtgewichtig und flexibel einsetzbar ist. 

\\ Ein weiterer Kandidat mit hohem Potenzial ist Ghostlab, welches zwar schon gute Allroundansätze derzeit vorweisen kann, jedoch leider im Detail nicht ausgereift ist. Die Nachfrage nach einem qualitativ hochwertigen Produkt ist vorhanden, wie es die große Anzahl\footnote{Eine große Auswahl findet sich z. B. unter http://opendevicelab.com/} an \Gls{Devicelab}s weltweit zeigt.

\\ Auch dem Ansatz ein eigenes Produkt für die spezifischen Anforderungen eines Betriebs zu entwickeln, steht in der Zukunft nichts im Wege, da bereits zu diesem Zeitpunkt \gls{NodeJS}, Socket.io und darauf aufbauende Technologien ein fundiertes Grundgerüst liefern. 
Dieses erfordert zwar eine leicht erhöhte Einarbeitungszeit, jedoch lassen sich hiermit die eigenen Spezifikationen verfolgen und umsetzen. Weiterhin förderlich, ist auch die sehr große und aktive Community rund um die genannten \Gls{Framework}s, welche auch in Zukunft voraussichtlich viele Einzelaspekte verfolgen, die sich dann einfach über das \gls{NodeJS}-eigene Paketverwaltungstool implementieren lassen.








